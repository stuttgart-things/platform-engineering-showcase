---
version: "3"
vars:
  KUBECONFIG_FOLDER: ~/.kube
  KCL_ANSIBLE_PR_PACKAGE: oci://ghcr.io/stuttgart-things/kcl-tekton-pr
  KCL_ANSIBLE_PR_VERSION: 0.2.1
  ANSIBLE_WORKING_IMAGE: ghcr.io/stuttgart-things/sthings-ansible:11.0.0
  ALL_ANSIBLE_PLAYBOOKS: "sthings.baseos.prepare_env,sthings.baseos.setup,sthings.apps.deploy"
  ALL_ANSIBLE_COLLECTIONS: "community.crypto:2.22.3,community.general:10.1.0,ansible.posix:2.0.0,kubernetes.core:5.0.0,community.docker:4.1.0,community.vmware:5.2.0,awx.awx:24.6.1,community.hashi_vault:6.2.0,ansible.netcommon:7.1.0,https://github.com/stuttgart-things/ansible/releases/download/sthings-container-25.0.286.tar.gz/sthings-container-25.0.286.tar.gz,https://github.com/stuttgart-things/ansible/releases/download/sthings-baseos-25.6.990.tar.gz/sthings-baseos-25.6.990.tar.gz,https://github.com/stuttgart-things/ansible/releases/download/sthings-awx-25.4.506.tar.gz/sthings-awx-25.4.506.tar.gz,https://github.com/stuttgart-things/ansible/releases/download/sthings-rke-25.6.394.tar.gz/sthings-rke-25.6.394.tar.gz"

tasks:
  create:buildah:pipelinerun:
    desc: Run buildah build
    vars:
      EXPORT_CMD_KUBECONFIG:
        sh: task --taskfile tekton-runs.yaml kube | grep '^export KUBECONFIG' | tail -n1
    cmds:
      - |
        {{ .EXPORT_CMD_KUBECONFIG }}
        kubectl get nodes

        # Ask for StorageClass
        SELECTED_SC=$(kubectl get sc -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' | gum choose --header "Select the StorageClass to use for provisioning volumes")
        echo "Selected StorageClass: ${SELECTED_SC}"

        OUTPUT_FILE="/tmp/buildah-pr.yaml"

        kcl run oci://ghcr.io/stuttgart-things/kcl-tekton-buildah -D --quiet \
        | tee "${OUTPUT_FILE}"

        cat "${OUTPUT_FILE}"

        #gitUrl=https://github.com/stuttgart-things/stage-time \
        #-D branchName=main \
        #-D context=tests/test-app \
        #-D verifySsl='"true"'

#        | kubectl -n tekton-ci apply -f -


  create:ansible:pipelinerun:
    desc: Run ansible playbook to prepare base OS
    vars:
      EXPORT_CMD_KUBECONFIG:
        sh: task --taskfile tekton-runs.yaml kube | grep '^export KUBECONFIG' | tail -n1
      INVENTORY:
        sh: task --taskfile tekton-runs.yaml build:ansible:inventory
      PLAYBOOKS:
        sh: task --taskfile tekton-runs.yaml listitems={{ .ALL_ANSIBLE_PLAYBOOKS }} pr:select:list
      COLLECTIONS:
        sh: task --taskfile tekton-runs.yaml listitems={{ .ALL_ANSIBLE_COLLECTIONS }} pr:select:list
      DEFAULT_PREFIX:
        sh: echo "pr-ansible"
    cmds:
      - |
        echo ""  # Just to show the selected playbooks

        {{ .EXPORT_CMD_KUBECONFIG }}
        kubectl get nodes

        # Ask for StorageClass
        SELECTED_SC=$(kubectl get sc -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' | gum choose --header "Select the StorageClass to use for provisioning volumes")
        echo "Selected StorageClass: ${SELECTED_SC}"

        # Ask for Namespace
        SELECTED_NAMESPACE=$(kubectl get ns -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' | gum choose --header "Select the Namespace to use for the pipeline run")
        echo "Selected Namespace: ${SELECTED_NAMESPACE}"

        # Ask for Ansible working image (default = {{ .ANSIBLE_WORKING_IMAGE }})
        ANSIBLE_IMAGE=$(gum input --header "Enter the Ansible working image" --placeholder "Enter Ansible working image" --value "{{ .ANSIBLE_WORKING_IMAGE }}")
        echo "Using Ansible working image: ${ANSIBLE_IMAGE}"

        # Ask for pipeline prefix (default = {{ .DEFAULT_PREFIX }})
        PIPELINE_PREFIX=$(gum input --header "Enter the pipeline prefix" --placeholder "Enter pipeline prefix" --value "{{ .DEFAULT_PREFIX }}")
        echo "Using pipeline prefix: ${PIPELINE_PREFIX}"

        # Run KCL pipeline and save to file
        OUTPUT_FILE="/tmp/pipelinerun.yaml"
        echo "Generating Tekton PipelineRun manifest with KCL..."
        kcl run --quiet {{ .KCL_ANSIBLE_PR_PACKAGE }}:{{ .KCL_ANSIBLE_PR_VERSION }} \
          -D ansibleWorkingImage="${ANSIBLE_IMAGE}" \
          -D storageClass="${SELECTED_SC}" \
          -D pipelinePrefix="${PIPELINE_PREFIX}" \
          -D pipelinePrefix="${PIPELINE_PREFIX}" \
          -D ansiblePlaybooks='{{ .PLAYBOOKS }}' \
          -D ansibleExtraCollections='{{ .COLLECTIONS }}' \
          -D inventory="{{ .INVENTORY }}" \
          | tee "${OUTPUT_FILE}"

        echo "KCL output saved to ${OUTPUT_FILE}"

        # Apply to cluster
        echo "Applying PipelineRun to cluster..."
        kubectl apply -f "${OUTPUT_FILE}" -n "${SELECTED_NAMESPACE}"

        # Optionally show the created PipelineRun
        gum spin --title "Creating tekton pipelinerun.." -- sleep 5
        tkn pr list -n "${SELECTED_NAMESPACE}"

        # Get the most recent PipelineRun name
        LATEST_PR=$(tkn pr list -n "${SELECTED_NAMESPACE}" --no-headers | head -n1 | awk '{print $1}')
        echo "Most recent PipelineRun: ${LATEST_PR}"

        # Show logs for that PipelineRun
        if [ -n "${LATEST_PR}" ]; then
          echo "Fetching logs for ${LATEST_PR}..."
          tkn pr logs "${LATEST_PR}" -n "${SELECTED_NAMESPACE}" -f
        else
          echo "No PipelineRun found in namespace ${SELECTED_NAMESPACE}!"
        fi

        echo "Check logs with 'tkn pr logs ${LATEST_PR} -n ${SELECTED_NAMESPACE} -f'"

  build:ansible:inventory:
    desc: Interactively build an Ansible inventory and print it Base64-encoded
    silent: true
    cmds:
      - |
        gum spin --title "Creating ansible inventory.." -- sleep 2
        INVENTORY=""
        while true; do
          GROUP=$(gum input --placeholder "Enter inventory group name (or leave empty to finish)")
          if [ -z "$GROUP" ]; then
            break
          fi

          INVENTORY="${INVENTORY}\n[${GROUP}]"

          while true; do
            HOST=$(gum input --placeholder "Enter host for group '$GROUP' (or leave empty to finish group)")
            if [ -z "$HOST" ]; then
              break
            fi
            INVENTORY="${INVENTORY}\n${HOST}"
          done

          INVENTORY="${INVENTORY}\n"
        done

        # Trim leading newline and encode
        ENCODED=$(echo -e "$INVENTORY" | sed '/^$/d' | base64 -w0)
        echo "$ENCODED"

  kube:
    desc: Select kubeconfig
    cmds:
      - |
        EXPORT_CMD_KUBECONFIG=$(gum choose {{ .ALL_KUBECONFIGS }} --header "Select the Kubeconfig to use")
        echo SWITCHING TO ${EXPORT_CMD_KUBECONFIG//\"/}
        export KUBECONFIG={{ .KUBECONFIG_FOLDER }}/${EXPORT_CMD_KUBECONFIG//\"/}
        kubectl get nodes
        printf "\n\nexport KUBECONFIG={{ .KUBECONFIG_FOLDER }}/${EXPORT_CMD_KUBECONFIG//\"/}\n\n"
    vars:
      ALL_KUBECONFIGS:
        sh: ls {{ .KUBECONFIG_FOLDER }} | xargs -n1 printf '"%s" '

  do:
    desc: Select a task to run
    cmds:
      - |
        task=$(yq e '.tasks | keys' tekton-runs.yaml  | sed 's/^- //' | gum choose)
        task --taskfile tekton-runs.yaml  ${task}

  pr:select:list:
    desc: Get list items
    silent: true
    cmds:
      - |
        SELECTED=$(echo "{{.listitems}}" | tr ',' '\n' | gum choose --no-limit)

        if [ -z "$SELECTED" ]; then
          echo "No list items selected"
          exit 1
        fi

        # Convert to JSON array format
        JSON_ARRAY=$(echo "$SELECTED" | awk '{printf "\"%s\", ", $0}' | sed 's/, $//')
        SELECTED_LIST_ITEMS="[${JSON_ARRAY}]"

        echo "${SELECTED_LIST_ITEMS}"
